# /dm:auto — 全自动流水线模式

> 生成日期：2026-02-26

## 背景

DevMind 的 explore → plan → build 工作流设计上强调人工确认，有效避免了 AI 的失控改动。
但对于日常的低风险需求（修 bug、加小功能、局部重构），每次都需要手动切换模式、逐步确认，
打断了开发节奏，降低了自动化程度。

`/dm:auto` 的目标是：**对明确、低风险的需求，一句话触发，全程自动完成**；同时对高风险改动保留门控，不盲目执行。

## 方案设计

### 流水线结构

五个阶段顺序执行，低风险时全程无需人工干预：

```
阶段 0：启动准备
  └─ 加载 memory/index.md
  └─ 检索 graveyard/（发现相似否决方案则暂停）

阶段 1：Explore（自动，无确认）
  └─ 定位相关文件和模块
  └─ 评估改动影响范围
  └─ 输出探索摘要（3-5 条）→ 直接推进

阶段 2：Plan + 风险评估（门控节点）
  └─ 生成执行方案
  └─ 自动评估风险 → 低风险继续 / 高风险暂停确认

阶段 3：生成 Spec（自动，无确认）
  └─ 写入 current-plan.md（标准 Spec 格式）→ 直接推进

阶段 4：Build（自动，遇边界暂停）
  └─ 按步骤实现
  └─ 每步写入 session.yaml 检查点

阶段 5：验证与收尾
  └─ 运行 lint / 类型检查 / 测试
  └─ 输出完成摘要
```

### 风险门控逻辑

**低风险（全部满足时自动推进）：**
- 涉及文件 ≤ 5 个
- 不新增 npm/pip/go 依赖
- 不修改 hook 脚本、配置文件 schema
- 不涉及数据库 migration 或破坏性 API 变更
- 改动类型为：新增文件、修改局部函数、增加配置项

**高风险（任一满足时暂停等待确认）：**
- 涉及文件 > 5 个
- 需要新增依赖
- 需要修改核心基础设施（hooks、auth、数据库）
- 改动影响多个模块的公共接口
- 存在不确定的技术方案需要选择

### 模式状态管理

- 阶段 1-2：写入 `explore` 到 `current-mode.txt`（Hook 拦截写操作）
- 阶段 3-4：写入 `build` 到 `current-mode.txt`（Hook 允许写操作）
- 现有 Hook 机制**完全复用**，不绕过任何安全约束

## 功能范围

**本次实现：**
- `.claude/commands/dm/auto.md` — 完整的流水线 Prompt
- `.claude/CLAUDE.md` 命令速览表新增 `/dm:auto` 条目

**明确排除（本次不做）：**
- 不修改任何 hook 脚本
- 不修改 config.yaml schema
- 不新增 CLI 子命令（纯 slash command 实现）
- 不支持并行步骤（顺序执行）

## 关键决策

**决策 1：方案 B（带门控）而非方案 A（完全自动）**

方案 A 完全无确认，自动化程度最高，但对高风险改动无保护。
方案 B 增加一次风险评估门控，低风险全自动，高风险暂停一次确认。
选择 B 的原因：大多数日常需求都是低风险的，门控几乎不增加摩擦；
但对少数复杂任务，一次确认能有效防止跑偏，收益远大于成本。

**决策 2：复用现有 Hook，不新增模式标识符**

`auto` 不是一个新的持久模式，而是一个临时流水线。
执行过程中复用 `explore` 和 `build` 两个已有模式，
不修改 Hook 逻辑，确保安全约束一致性。

**决策 3：以文件数量和依赖变化作为风险代理指标**

风险评估需要客观、可观察的指标，而不是主观判断。
文件数量（> 5）和新增依赖是最直接的代理指标，误判率低且易于理解。

## 已知限制 / 后续计划

- **风险评估准确性**：基于文件数量的门控是粗粒度的，可能低估某些单文件高风险改动（如修改核心接口）。后续可考虑增加"文件类型权重"（hook 文件、数据库 schema 文件权重更高）。
- **无并发步骤**：当前顺序执行，对于可以并行的步骤（如同时修改多个独立文件）没有优化。
- **断点续传**：auto 模式在 build 阶段暂停后，目前通过 `/dm:build` 续传，尚未有专用的 `/dm:auto resume` 语法。
